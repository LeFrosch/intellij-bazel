load("@rules_java//java:defs.bzl", "java_binary")
load("@rules_pkg//pkg:zip.bzl", "pkg_zip")

load(":module.bzl", "ModuleInfo")
load(":debug.bzl", _intellij_debug = "intellij_debug")

def _write_module_xml(ctx, info):
    plugin_id = ctx.attr.plugin_id
    plugin_xml_file = info.plugin_xml

    module_xml_name = "%s.%s.xml" % (plugin_id, info.name)
    module_xml_file = ctx.actions.declare_file(module_xml_name)

    deps = [
        struct(
            name = "%s.%s" % (plugin_id, dep.name),
            optional = dep.optional,
        )
        for dep in info.deps_direct.to_list()
    ]

    input = proto.encode_text(struct(
        plugin_id = plugin_id,
        output = module_xml_file.path,
        module = struct(
            name = info.name,
            package = info.package,
            plugin_xml = plugin_xml_file.path if plugin_xml_file else "",
            deps = deps,
        ),
    ))

    ctx.actions.run(
        executable = ctx.executable._module_xml_builder,
        arguments = [input],
        inputs = [plugin_xml_file] if plugin_xml_file else [],
        outputs = [module_xml_file],
        progress_message = "Building module xml file",
        mnemonic = "BuildModuleXml",
    )

    return module_xml_file

def _write_plugin_xml(ctx):
    plugin_id = ctx.attr.plugin_id
    plugin_xml_file = ctx.file.plugin_xml

    module_xml_name = "%s.xml" % plugin_id
    module_xml_file = ctx.actions.declare_file(module_xml_name)

    deps = [
        struct(
            name = "%s.%s" % (plugin_id, dep[ModuleInfo].name),
            optional = dep[ModuleInfo].optional,
        )
        for dep in ctx.attr.deps
    ]

    input = proto.encode_text(struct(
        output = module_xml_file.path,
        plugin = struct(
            id = plugin_id,
            name = ctx.attr.plugin_name,
            vendor = ctx.attr.vendor,
            version = ctx.attr.version,
            package = ctx.attr.package,
            plugin_xml = plugin_xml_file.path if plugin_xml_file else "",
            deps = deps,
        ),
    ))

    ctx.actions.run(
        executable = ctx.executable._plugin_xml_builder,
        arguments = [input],
        inputs = [plugin_xml_file] if plugin_xml_file else [],
        outputs = [module_xml_file],
        progress_message = "Building plugin xml file",
        mnemonic = "BuildPluginXml",
    )

    return module_xml_file

def _write_plugin_jar(ctx, module_xmls, plugin_xml):
    jar_name = "%s.jar" % ctx.label.name
    jar_file = ctx.actions.declare_file(jar_name)

    input = proto.encode_text(struct(
        output = jar_file.path,
        plugin = struct(
            impl_jar = ctx.file.impl.path,
            module_xmls = [file.path for file in module_xmls],
            plugin_xml = plugin_xml.path,
        ),
    ))

    ctx.actions.run(
        executable = ctx.executable._jar_builder,
        arguments = [input],
        inputs = [ctx.file.impl, plugin_xml] + module_xmls,
        outputs = [jar_file],
        progress_message = "Building plugin jar",
        mnemonic = "BuildPluginJar",
    )

    return jar_file

def _intellij_plugin_impl(ctx):
    deps = [dep[ModuleInfo] for dep in ctx.attr.deps]
    modules = depset(direct = deps, transitive = [dep.deps_transitive for dep in deps]).to_list()

    module_xmls = [_write_module_xml(ctx, module) for module in modules]
    plugin_xml = _write_plugin_xml(ctx)
    plugin_jar = _write_plugin_jar(ctx, module_xmls, plugin_xml)

    return [DefaultInfo(files = depset([plugin_jar]))]

_intellij_plugin = rule(
    implementation = _intellij_plugin_impl,
    attrs = {
        "deps": attr.label_list(providers = [ModuleInfo]),
        "impl": attr.label(mandatory = True, allow_single_file = [".jar"]),
        "package": attr.string(mandatory = True),
        "plugin_xml": attr.label(allow_single_file = [".xml"]),
        "plugin_id": attr.string(mandatory = True),
        "plugin_name": attr.string(mandatory = True),
        "vendor": attr.string(mandatory = True),
        "version": attr.string(mandatory = True),
        "_module_xml_builder": attr.label(
            default = Label("//rules_intellij/builder:module"),
            executable = True,
            cfg = "exec",
        ),
        "_plugin_xml_builder": attr.label(
            default = Label("//rules_intellij/builder:plugin"),
            executable = True,
            cfg = "exec",
        ),
        "_jar_builder": attr.label(
            default = Label("//rules_intellij/builder:jar"),
            executable = True,
            cfg = "exec",
        )
    },
)

def intellij_plugin(
        name,
        package,
        plugin_id,
        plugin_name,
        plugin_lib,
        vendor,
        version,
        plugin_xml = None,
        resources = [],
        deps = []):

    # both are generated by the java_binary target
    binary_name = "%s_binary" % name
    deploy_name = "%s_deploy.jar" % binary_name

    jar_name = "%s_plugin" % name
    debug_name = "%s_dev" % name

    java_binary(
        name = binary_name,
        runtime_deps = deps,
        create_executable = 0,
    )

    _intellij_plugin(
        name = jar_name,
        deps = deps,
        impl = deploy_name,
        package = package,
        plugin_xml = plugin_xml,
        plugin_id = plugin_id,
        plugin_name = plugin_name,
        vendor = vendor,
        version = version,
    )

    # create debug target for IJwB, TODO: create bazel target to run the plugin
    _intellij_debug(
        name = debug_name,
        plugin_jar = jar_name,
        resources = resources,
    )

    pkg_zip(
        name = name,
        srcs = [jar_name] + resources,
        package_dir = "%s/lib" % plugin_lib,
    )
